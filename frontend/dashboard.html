<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Messenger - Dashboard</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div id="app">
        <header>
            <h2>Wiadomości</h2>
            <div id="userHeader">
                Zalogowany jako: <strong id="meName">—</strong>
                <button id="logoutBtn">Wyloguj</button>
            </div>
        </header>
        <div class="dashboard-container">
            <div id="usersList">
                <h3>Użytkownicy</h3>
                <ul id="users"></ul>
            </div>
            <div id="conversation">
            <h3 id="convTitle">Wybierz użytkownika</h3>
            <div id="messages"></div>
            <form id="sendForm" enctype="multipart/form-data">
                <input type="text" id="msgInput" placeholder="Napisz wiadomość..." required>
                <input type="file" id="fileInput" name="attachments" multiple>
                <div id="attachmentsList"></div>
                <button type="submit">Wyślij</button>
            </form>
        </div>
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsbn/1.1/jsbn.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsencrypt/3.3.0/jsencrypt.min.js"></script>
    <script>
    let selectedUser = null;
    let myId = null;
    let privateKeyDecrypted = null;  // Zapamiętany klucz prywatny

    async function fetchMyId() {
        const res = await fetch('/api/me', { credentials: 'same-origin' });
        const data = await res.json();
        myId = data.id;
        const nameEl = document.getElementById('meName');
        if (data && data.username) nameEl.textContent = data.username; else nameEl.textContent = '—';
        
        // Załaduj klucz prywatny z sessionStorage (został pobrana przy logowaniu)
        privateKeyDecrypted = sessionStorage.getItem('privateKeyDecrypted');
        if (!privateKeyDecrypted) {
            alert('⚠️ Klucz prywatny nie jest dostępny. Proszę zalogować się ponownie.');
            window.location.href = 'login.html';
        }
    }
    
    function generateAESKey() {
        // Generuje losowy klucz AES-256 w Base64
        return CryptoJS.lib.WordArray.random(32).toString(CryptoJS.enc.Base64);
    }
    
    function encryptAES(plaintext, aesKeyB64) {
        try {
            const encrypted = CryptoJS.AES.encrypt(plaintext, CryptoJS.enc.Base64.parse(aesKeyB64), {
                mode: CryptoJS.mode.ECB,
                padding: CryptoJS.pad.Pkcs7
            });
            return encrypted.toString();
        } catch (error) {
            console.error('AES encryption error:', error);
            return null;
        }
    }
    
    async function encryptAESKeyWithPublicKey(aesKeyB64, recipientPublicKeyPEM) {
        try {
            const encrypt = new JSEncrypt();
            encrypt.setPublicKey(recipientPublicKeyPEM);
            const encryptedKey = encrypt.encrypt(aesKeyB64);
            return encryptedKey;
        } catch (error) {
            console.error('RSA encryption error:', error);
            return null;
        }
    }
    
    async function signMessage(plaintext) {
        try {
            // Utwórz hash SHA-256
            const hash = CryptoJS.SHA256(plaintext).toString();
            
            // Podpisz hash kluczem prywatnym za pomocą JSEncrypt
            const sign = new JSEncrypt();
            sign.setPrivateKey(privateKeyDecrypted);
            const signature = sign.sign(hash, CryptoJS.SHA256, 'sha256');
            
            return signature || null;
        } catch (error) {
            console.error('Signing error:', error);
            return null;
        }
    }
    
    async function decryptAESKey(encryptedAESKeyOrJson) {
        try {
            // Obsługuj zarówno nowy format (JSON) jak i stary format (string)
            let encryptedAESKeyB64 = encryptedAESKeyOrJson;
            
            if (typeof encryptedAESKeyOrJson === 'string' && encryptedAESKeyOrJson.startsWith('{')) {
                try {
                    const data = JSON.parse(encryptedAESKeyOrJson);
                    // Najpierw spróbuj odszyfrować z moim kluczem (dla wysłanych wiadomości)
                    if (data.s) {
                        const decrypt = new JSEncrypt();
                        decrypt.setPrivateKey(privateKeyDecrypted);
                        const aesKeyB64 = decrypt.decrypt(data.s);
                        if (aesKeyB64) return aesKeyB64;
                    }
                    // Potem spróbuj z kluczem dla odbiorcy (dla otrzymanych wiadomości)
                    if (data.r) {
                        encryptedAESKeyB64 = data.r;
                    }
                } catch (e) {
                    console.error('JSON parse error:', e);
                }
            }
            
            // Odszyfruj AES key używając klucza prywatnego
            const decrypt = new JSEncrypt();
            decrypt.setPrivateKey(privateKeyDecrypted);
            const aesKeyB64 = decrypt.decrypt(encryptedAESKeyB64);
            return aesKeyB64 || null;
        } catch (error) {
            console.error('AES key decryption error:', error);
            return null;
        }
    }
    
    function decryptAES(encryptedContent, aesKeyB64) {
        try {
            const decrypted = CryptoJS.AES.decrypt(encryptedContent, CryptoJS.enc.Base64.parse(aesKeyB64), {
                mode: CryptoJS.mode.ECB,
                padding: CryptoJS.pad.Pkcs7
            });
            return decrypted.toString(CryptoJS.enc.Utf8);
        } catch (error) {
            console.error('AES decryption error:', error);
            return null;
        }
    }
    
    async function getSenderPublicKey(senderId) {
        try {
            const res = await fetch(`/api/users/${senderId}/public-key`, {
                credentials: 'same-origin'
            });
            if (!res.ok) return null;
            const data = await res.json();
            return data.public_key;
        } catch (error) {
            console.error('Error fetching sender public key:', error);
            return null;
        }
    }
    
    async function verifySignature(plaintext, signature, senderPublicKeyPEM) {
        try {
            const hash = CryptoJS.SHA256(plaintext).toString();
            const verify = new JSEncrypt();
            verify.setPublicKey(senderPublicKeyPEM);
            return verify.verify(hash, signature, CryptoJS.SHA256);
        } catch (error) {
            console.error('Signature verification error:', error);
            return false;
        }
    }

    document.getElementById('logoutBtn').onclick = async function() {
        await fetch('/api/logout', { method: 'POST', credentials: 'same-origin' });
        localStorage.removeItem('loggedIn');
        window.location.href = 'login.html';
    };

    async function fetchUsers() {
        const res = await fetch('/api/users');
        const users = await res.json();
        const ul = document.getElementById('users');
        ul.innerHTML = '';
        users.forEach(u => {
            const li = document.createElement('li');
            li.textContent = u.username;
            li.dataset.id = u.id;
            li.onclick = () => selectUser(u);
            if (selectedUser && selectedUser.id === u.id) li.classList.add('selected');
            ul.appendChild(li);
        });
    }

    async function fetchMessages(userId) {
        const res = await fetch(`/api/messages/conversation/${userId}`);
        if (!res.ok) return;
        const data = await res.json();
        const messagesDiv = document.getElementById('messages');
        messagesDiv.innerHTML = '';
        
        for (const m of data.messages) {
            const wrapper = document.createElement('div');
            wrapper.className = 'message-item';
            const who = (m.sender_id === myId) ? 'Ty' : m.sender;
            
            let text = '';
            let isEncrypted = m.encrypted_content && m.session_key_encrypted;
            
            // Jeśli to wiadomość którą wysłałaś - mogę ją teraz odszyfrować (mam klucz)
            if (m.sender_id === myId) {
                if (isEncrypted) {
                    const aesKeyB64 = await decryptAESKey(m.session_key_encrypted);
                    if (!aesKeyB64) {
                        text = `${who}: [Błąd odszyfrowywania klucza wysłanej wiadomości]`;
                    } else {
                        const plaintext = decryptAES(m.encrypted_content, aesKeyB64);
                        if (!plaintext) {
                            text = `${who}: [Błąd odszyfrowywania wysłanej wiadomości]`;
                        } else {
                            text = `${who}: ${plaintext}`;
                        }
                    }
                } else {
                    text = `${who}: [Wiadomość wysłana]`;
                }
                text += m.is_read ? ' ✓ Odczytane' : ' ☐ Wysłane';
            } else {
                // Jeśli to wiadomość którą otrzymałaś - odszyfruj
                if (isEncrypted) {
                    const aesKeyB64 = await decryptAESKey(m.session_key_encrypted);
                    if (!aesKeyB64) {
                        text = `${who}: [Błąd odszyfrowywania klucza]`;
                    } else {
                        const plaintext = decryptAES(m.encrypted_content, aesKeyB64);
                        if (!plaintext) {
                            text = `${who}: [Błąd odszyfrowywania wiadomości]`;
                        } else {
                            // Weryfikuj podpis jeśli dostępny
                            let signatureValid = false;
                            if (m.signature) {
                                const senderPublicKey = await getSenderPublicKey(m.sender_id);
                                if (senderPublicKey) {
                                    signatureValid = await verifySignature(plaintext, m.signature, senderPublicKey);
                                }
                            }
                            text = `${who}: ${plaintext}`;
                            if (signatureValid) {
                                text += ' ✓';
                            }
                        }
                    }
                } else {
                    text = `${who}: [Niezaszyfrowana wiadomość]`;
                }
            }
            
            const textNode = document.createElement('span');
            textNode.textContent = text;
            wrapper.appendChild(textNode);

            if (m.attachments && m.attachments.length) {
                const attList = document.createElement('div');
                attList.style.marginTop = '6px';
                m.attachments.forEach(a => {
                    const aLink = document.createElement('a');
                    aLink.href = `/api/attachments/${a.id}`;
                    aLink.textContent = a.filename;
                    aLink.target = '_blank';
                    aLink.style.display = 'inline-block';
                    aLink.style.marginRight = '8px';
                    attList.appendChild(aLink);
                });
                wrapper.appendChild(attList);
            }

            if (m.sender_id === myId) {
                const delBtn = document.createElement('button');
                delBtn.textContent = 'Usuń';
                delBtn.className = 'delete-btn';
                delBtn.onclick = async (e) => {
                    e.stopPropagation();
                    if (!confirm('Na pewno usunąć wiadomość?')) return;
                    const res = await fetch(`/api/messages/${m.id}`, { method: 'DELETE' });
                    if (res.status === 204) {
                        fetchMessages(selectedUser.id);
                    } else {
                        const err = await res.json();
                        alert(err.error || 'Błąd usuwania');
                    }
                };
                wrapper.appendChild(delBtn);
            }

            messagesDiv.appendChild(wrapper);
        }
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    let pollIntervalId = null;
    let usersIntervalId = null;

    function startUsersPolling(){
        if (usersIntervalId) return;
        usersIntervalId = setInterval(fetchUsers, 10000);
    }

    function stopUsersPolling(){
        if (!usersIntervalId) return;
        clearInterval(usersIntervalId);
        usersIntervalId = null;
    }

    function startConversationPolling(userId){
        if (pollIntervalId) clearInterval(pollIntervalId);
        pollIntervalId = setInterval(()=>{
            if (selectedUser) fetchMessages(selectedUser.id);
        }, 2000);
    }

    function stopConversationPolling(){
        if (pollIntervalId) clearInterval(pollIntervalId);
        pollIntervalId = null;
    }

    function selectUser(user) {
        selectedUser = user;
        document.getElementById('convTitle').textContent = 'Rozmowa z: ' + user.username;
        document.getElementById('sendForm').style.display = 'flex';
        document.querySelectorAll('#users li').forEach(li => li.classList.remove('selected'));
        const node = Array.from(document.querySelectorAll('#users li')).find(n => n.dataset.id == user.id);
        if (node) node.classList.add('selected');
        fetchMessages(user.id);
        startConversationPolling(user.id);
    }

    function updateAttachmentsList() {
        const fileInput = document.getElementById('fileInput');
        const attachmentsList = document.getElementById('attachmentsList');
        attachmentsList.innerHTML = '';
        if (!fileInput.files.length) return;
        const listDiv = document.createElement('div');
        listDiv.style.marginTop = '8px';
        listDiv.style.padding = '8px';
        listDiv.style.backgroundColor = '#f0f0f0';
        listDiv.style.borderRadius = '4px';
        const title = document.createElement('strong');
        title.textContent = 'Załączniki (' + fileInput.files.length + '):';
        listDiv.appendChild(title);
        const fileList = document.createElement('div');
        fileList.style.marginTop = '6px';
        Array.from(fileInput.files).forEach((file, index) => {
            const fileItemDiv = document.createElement('div');
            fileItemDiv.style.display = 'flex';
            fileItemDiv.style.justifyContent = 'space-between';
            fileItemDiv.style.alignItems = 'center';
            fileItemDiv.style.padding = '4px';
            fileItemDiv.style.borderBottom = '1px solid #ddd';
            const nameSpan = document.createElement('span');
            nameSpan.textContent = file.name + ' (' + (file.size / 1024).toFixed(1) + ' KB)';
            fileItemDiv.appendChild(nameSpan);
            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.textContent = '✕';
            removeBtn.style.padding = '2px 8px';
            removeBtn.style.backgroundColor = '#ff6b6b';
            removeBtn.style.color = 'white';
            removeBtn.style.border = 'none';
            removeBtn.style.borderRadius = '3px';
            removeBtn.style.cursor = 'pointer';
            removeBtn.onclick = (e) => {
                e.preventDefault();
                const dt = new DataTransfer();
                Array.from(fileInput.files).forEach((f, i) => {
                    if (i !== index) dt.items.add(f);
                });
                fileInput.files = dt.files;
                updateAttachmentsList();
            };
            fileItemDiv.appendChild(removeBtn);
            fileList.appendChild(fileItemDiv);
        });
        listDiv.appendChild(fileList);
        attachmentsList.appendChild(listDiv);
    }

    document.getElementById('fileInput').onchange = updateAttachmentsList;

    document.getElementById('sendForm').onsubmit = async function(e) {
        e.preventDefault();
        if (!selectedUser) return;
        if (!privateKeyDecrypted) {
            alert('Klucz prywatny nie jest załadowany!');
            return;
        }
        
        const msg = document.getElementById('msgInput').value;
        
        // Pobierz klucz publiczny odbiorcy
        try {
            const keyRes = await fetch(`/api/users/${selectedUser.id}/public-key`, {
                credentials: 'same-origin'
            });
            const keyData = await keyRes.json();
            if (!keyRes.ok) {
                alert('Błąd: ' + (keyData.error || 'Nie znaleziono klucza publicznego'));
                return;
            }
            
            // Generuj losowy klucz AES
            const aesKeyB64 = generateAESKey();
            
            // Szyfruj wiadomość
            const encryptedContent = encryptAES(msg, aesKeyB64);
            if (!encryptedContent) {
                alert('Błąd szyfrowania wiadomości');
                return;
            }
            
            // Szyfruj klucz AES kluczem publicznym odbiorcy
            const encryptedAESKey_recipient = await encryptAESKeyWithPublicKey(aesKeyB64, keyData.public_key);
            if (!encryptedAESKey_recipient) {
                alert('Błąd szyfrowania klucza dla odbiorcy');
                return;
            }
            
            // Również szyfruj klucz AES kluczem publicznym NADAWCY (aby mógł wyświetlić swoją wiadomość)
            // Pobierz mój klucz publiczny
            const myKeyRes = await fetch(`/api/users/${myId}/public-key`, {
                credentials: 'same-origin'
            });
            const myKeyData = await myKeyRes.json();
            let encryptedAESKey_sender = null;
            if (myKeyRes.ok) {
                encryptedAESKey_sender = await encryptAESKeyWithPublicKey(aesKeyB64, myKeyData.public_key);
            }
            
            // Podpisz wiadomość
            const signature = await signMessage(msg);
            if (!signature) {
                alert('Błąd podpisywania wiadomości');
                return;
            }
            
            // Zapamiętaj AES key dla siebie (do wyświetlenia swojej wiadomości)
            // Przechowuj w formacie: {r: "...", s: "...", k: "..."} gdzie k to oryginalny klucz
            const sessionKeyData = {
                r: encryptedAESKey_recipient,  // dla odbiorcy
                s: encryptedAESKey_sender,      // dla nadawcy
                k: aesKeyB64                    // oryginalny klucz (dla testów/debug)
            };
            
            // Wyślij zaszyfrowaną wiadomość
            const fileInput = document.getElementById('fileInput');
            const form = new FormData();
            form.append('recipient_id', selectedUser.id);
            form.append('encrypted_content', encryptedContent);
            form.append('session_key_encrypted', JSON.stringify(sessionKeyData));
            form.append('signature', signature);
            
            if (fileInput && fileInput.files.length) {
                for (let i = 0; i < fileInput.files.length; i++) {
                    form.append('attachments', fileInput.files[i]);
                }
            }
            
            const response = await fetch('/api/messages/send', {
                method: 'POST',
                body: form,
                credentials: 'same-origin'
            });
            const data = await response.json();
            if (!response.ok) {
                alert('Błąd wysyłania: ' + (data.error || 'Nieznany błąd'));
                return;
            }
            document.getElementById('msgInput').value = '';
            if (fileInput) fileInput.value = '';
            document.getElementById('attachmentsList').innerHTML = '';
            fetchMessages(selectedUser.id);
        } catch (error) {
            alert('Błąd: ' + error.message);
        }
    };

    (async ()=>{
        await fetchMyId();
        await fetchUsers();
        startUsersPolling();
    })();
    </script>
</body>
</html>
